import numpy as np
from scipy.special import ellipk, ellipe

# Magnetic field due to a circular coil at the origin
def B_from_TF_coils(x, y, z, I, first_wall_polygon2D=None):
    mu_0 = 4 * np.pi * 1e-7  # Permeability of free space

    # Convert Cartesian coordinates to cylindrical coordinates
    rho = np.sqrt(x**2 + y**2)
    phi = np.arctan2(y, x)

    # Magnetic field components in cylindrical coordinates
    B_phi = mu_0 * I / (2 * np.pi * rho)

    # Convert cylindrical components to Cartesian components
    B_x = -B_phi * np.sin(phi)
    B_y = B_phi * np.cos(phi)
    B_z = 0.0
    B = np.array([B_x, B_y, B_z])
    return B

def B_from_circular_coil(x, y, z, I, a):
    mu_0 = 4 * np.pi * 1e-7  # Permeability of free space

    # Convert Cartesian coordinates to cylindrical coordinates
    rho = np.sqrt(x**2 + y**2)
    phi = np.arctan2(y, x)

    # Elliptic integrals
    k_sq = 4 * a * rho / ((a + rho)**2 + z**2)
    K = ellipk(k_sq)
    E = ellipe(k_sq)

    # Magnetic field components in cylindrical coordinates
    if rho == 0:
        B_z = (mu_0 * I / (2 * a)) * (1 / np.sqrt(a**2 + z**2))
        B_x = 0.0
        B_y = 0.0
        B = np.array([B_x, B_y, B_z])
        return B
    B_rho = (mu_0 * I / (2 * np.pi)) * (z / (rho * np.sqrt((a + rho)**2 + z**2))) * (-K + ((a**2 + rho**2 + z**2) / ((a - rho)**2 + z**2)) * E)
    B_z = (mu_0 * I / (2 * np.pi)) * (1 / np.sqrt((a + rho)**2 + z**2)) * (K + ((a**2 - rho**2 - z**2) / ((a - rho)**2 + z**2)) * E)

    # Convert cylindrical components to Cartesian components
    B_x = B_rho * np.cos(phi)
    B_y = B_rho * np.sin(phi)
    B = np.array([B_x, B_y, B_z])
    return B


def E_from_circular_capacitor(x, y, z, Q, a, d):
    """
    Calculate the electric field from a capacitor.
    Parameters:
    x (float): x-coordinate of the point where the electric field is calculated.
    y (float): y-coordinate of the point where the electric field is calculated.
    z (float): z-coordinate of the point where the electric field is calculated.
    Q (float): Charge of the capacitor.
    a (float): Radius of the circular capacitor plates.
    d (float): Distance between the capacitor plates.
    Returns:
    numpy.ndarray: Electric field vector [E_x, E_y, E_z] at the given point.
                   Returns [0, 0, 0] if the point is outside the capacitor. Ignore the edge effects.
    """
    if x**2 + y**2 > a**2:
        return np.array([0, 0, 0])
    if z < -d/2 or z > d/2:
        return np.array([0, 0, 0])
    epsilon_0 = 8.85e-12  # Permittivity of free space
    E = Q / (2 * np.pi * epsilon_0 * a**2)
    return np.array([0, 0, E])

def B_from_circular_capacitor_charging(x, y, z, I, a, d):
    """
    Calculate the magnetic field generated by a cylindrical capacitor.
    Parameters:
    x (float): x-coordinate of the point where the magnetic field is calculated.
    y (float): y-coordinate of the point where the magnetic field is calculated.
    z (float): z-coordinate of the point where the magnetic field is calculated.
    I (float): Current flowing into the lower capacitor plate.
    a (float): Radius of the circular capacitor plates.
    d (float): Distance between the capacitor plates.
    Returns:
    numpy.ndarray: A 3-element array representing the magnetic field vector [Bx, By, Bz] at the given point.
    """

    mu_0 = 4 * np.pi * 1e-7  # Permeability of free space
    rho = np.sqrt(x**2 + y**2)
    if rho < a:
        B_phi = mu_0 * I * rho / (2 * np.pi * a**2)
    else:
        B_phi = mu_0 * I / (2 * np.pi * rho)
    return np.array([-B_phi * y / rho, B_phi * x / rho, 0])
